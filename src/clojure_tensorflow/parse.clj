(ns clojure-tensorflow.parse
  (:require [clojure-tensorflow.utils :as utils]
            [clojure.string :as string]
            [environ.core :refer [env]]
            [clojure-tensorflow.build :as build]))

(defn to-op-def
  "Takes vector of vectors in the form provided by tensorflow grad deps
  and returns a clojure map which can be used with build/op-builder"
  [c-def]
  {:name (gensym (first (first c-def)))
   :grad-scope-ref (first (first c-def))
   :operation (second c-def)
   :inputs (get c-def 2)
   :attrs (into {} (map
                    #(vector (keyword (first %)) (second %))
                    (get c-def 3)))
   })


;; C syntax helpers
(def remove-comments
  #(string/replace % #"//.*\n" "\n"))

(defn handle-fdh [s]
  (string/replace
    s #"FDH::Const\(\"(\w+)\"\,\s?(\d\.\d?)f?\)"
    #(str "{{\"" (nth %1 1) "\"}, "
          "\"Const\", " ;operation
          "{}, " ;inputs
          "{{\"dtype\", \"$T\"}, {\"value\", " (nth %1 2) "}}}" ;attrs
          )))

;; Directory
(def tf-ops-dir
  (str (env :tf-dir) "tensorflow/core/ops/"))

(def grad-files
  (filter
   (partial re-matches #".*grad.cc")
   (map #(.getName %)
        (.listFiles
         (java.io.File. tf-ops-dir)))))

(def math-grad
  (-> (apply str
             (map #(slurp (str tf-ops-dir %)) grad-files))
   remove-comments
   (string/replace #"\s" " ")))


(def calls-to-reg
  (re-seq #"REGISTER_OP_GRADIENT\(\"(\w+)\",\s?([\"\w]+)" math-grad))

(def matches
  (re-seq
   #"Status\s(\w+).*?(?=return)?\sGradFor(\w+)Cwise\(g\,\s([^;]+)"
   math-grad))

(def lookup
  (reduce
   merge (map (fn [m] {(nth m 1) (nth m 2)})
              calls-to-reg)))

(def nodes
  (reduce merge
   (map
    (fn [m] {(nth m 1)
            {:type (nth m 2)
             :gradient
             (apply str (drop-last (nth m 3)))}})
    matches
    )))


(def gradients
  (apply merge
         (map #(if (get nodes (second %))
                 (let [n (get nodes (second %))]
                     (try
                       {(first %)
                        {:type (:type n)
                         :gradient
                         (map to-op-def
                              (-> (:gradient n)
                                  (handle-fdh)
                                  (string/replace "{" "[")
                                  (string/replace "}" "]")
                                  read-string
                                  ))}}
                                        ;just discard breaking ops for now
                       (catch Exception e nil))))
              lookup)))



(keys gradients)

;; generate gradients file
(spit "resources/gradients.edn"
      (str ";; DO NOT edit this file directly\n"
           ";; please make changes in parse.clj\n"
           gradients
           ))
